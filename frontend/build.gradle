apply plugin: 'download-task'
apply plugin: 'kotlin' // we don't actually need this plugin, but IDEA won't even highlight kotlin syntax properly without it

def KOTLINC_ZIP_URL = 'https://github.com/JetBrains/kotlin/releases/download/build-0.8.11/kotlin-compiler-0.8.11.zip'

buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'de.undercouch:gradle-download-task:1.+'
    }
}

defaultTasks 'assemble'

tasks.assemble.dependsOn = [] // essentially turning kotlin plugin off
repositories {
    mavenCentral()
}
dependencies {
    compile 'org.jetbrains.kotlin:kotlin-js-library:0.8.11'
}

tasks.assemble.dependsOn 'compileJs'
tasks.assemble.dependsOn 'setupKotlinJsLibraryForIdea'

tasks.clean.dependsOn 'cleanFrontend'
task cleanFrontend {
    dependsOn 'cleanKotlinJsLibraryForIdea'
    doLast {
        delete 'build'
    }
}

task downloadKotlinCompiler {
    outputs.upToDateWhen {file('build/kotlin-compiler.zip').exists()}
    doLast {
        download {
            src  KOTLINC_ZIP_URL
            dest file('build/kotlin-compiler.zip')
        }
    }
}

def libJsFiles = ['kotlin-lib.js', 'kotlin-lib-ecma5.js', 'kotlin-maps.js']
task copyBundledKotlinJs {
    outputs.upToDateWhen { libJsFiles.find {!file('build/web/' + it).exists()} == null }
    doLast {
        def jsLib = project.configurations.compile.find { it.name.startsWith("kotlin-js-library-") }
        copy {
            from zipTree(file(jsLib))
            include libJsFiles
            into 'build/web'
        }
    }
}

task setupKotlinJsCompiler {
    dependsOn 'downloadKotlinCompiler'
    outputs.upToDateWhen {file('build/kotlinc/bin/kotlinc-js').exists()}
    doLast {
        def zipfile = file('build/kotlin-compiler.zip')
        assert zipfile.exists(), "Downloading kotlin compiler failed"

        copy {
            from zipTree(zipfile)
            into 'build'
        }

        assert file('build/kotlinc/bin/kotlinc-js').exists(), 'Downloaded kotlin compiler is corrupt'
    }
}

// unfortunately, IDEA seems to want .class files in jars, which kotlin-js-library doesn't have
// since it's compiled into JavaScript, so we copy its sources into our src directory
// to enable proper code completion and analysis
task setupKotlinJsLibraryForIdea {
    outputs.upToDateWhen {file('src/main/kotlin/kotlin-js-library').exists()}
    doLast {
        def jsLib = project.configurations.compile.find { it.name.startsWith("kotlin-js-library-") }
        copy {
            from(zipTree(file(jsLib))) {
                include '**/*.kt'
            }
            into 'src/main/kotlin/kotlin-js-library'
        }
    }
}
task cleanKotlinJsLibraryForIdea {
    doLast {
        delete 'src/main/kotlin/kotlin-js-library'
    }
}

task compileJs {
    dependsOn 'setupKotlinJsCompiler'
    dependsOn 'copyBundledKotlinJs'
    outputs.upToDateWhen {
        ArrayList<File> files = []
        file('src/main/kotlin').eachFileRecurse {
            if (it.name.endsWith('.kt') || it.isDirectory()) {
                files.add it
            }
        }
        file('../src/main/kotlin/beholder/backend/api').eachFileRecurse {
            if (it.name.endsWith('.kt') || it.isDirectory()) {
                files.add it
            }
        }
        def lastModTime = files.inject(null, {
            time, file ->
                def lastModified = file.lastModified()
                return (time == null || time < lastModified) ? lastModified : time
        })
        return lastModTime != null && lastModTime < file("build/web/script.js").lastModified()
    }
    doLast {
        def jsLib   = project.configurations.compile.find { it.name.startsWith("kotlin-js-library-") }
        def kotlinc = file('build/kotlinc/bin/kotlinc-js').canonicalPath
        def out     = file("build/web/script.js").canonicalPath

        def source    = file('src/main/kotlin/beholder').canonicalPath
        def apiSource = file('../src/main/kotlin/beholder/backend/api').canonicalPath

        // TODO proper argument escaping if possible
        def command = "${kotlinc} -sourcemap -output ${out} -libraryFiles ${jsLib} -sourceFiles ${source},${apiSource}"

        def proc = command.execute()
        proc.waitFor()
        assert proc.exitValue() == 0, "Command failed: ${command}\nCommand output:\n${proc.text}"
    }
}
