# report internal stats to stdout every minute
flow {
    from timer 60 seconds;
    parse beholder-stats;
    set $curtime time;
    set $payload '$curtime $payload';
    to stdout;
}

flow {
    from udp 3820;
    parse syslog;
    to stdout;
}

## listen on a UDP port and write every incoming packet as a line into a file
#flow {
#    from udp 1234;
#    to file /var/log/beholder/from-udp-1234.log;
#}

## receive nginx access log over UDP and write it into a file
#flow {
#    from udp 3820;
#    parse syslog;
#    to file '.../access.log';
#}

## send internal beholder log as syslog over UDP
#flow {
#    from internal-log;
#    set $payload syslog;
#    to udp 1234;
#}

## receive nginx logs by UDP and send them into syslog-ng over TCP
#flow {
#    from udp 3820;
#    parse syslog; # convert bsd-syslog into beholder fields
#
#    set $payload syslog; # convert beholder fields into ietf-syslog
#    set $payload "$payload\n";
#    set $payload syslog-frame; # syslog-ng wants the message to be prefixed with its length and a space
#    to tcp 10.64.1.1:5142;
#}

## send beholder stats as metrics into InfluxDB
#flow {
#    from timer 30 seconds;
#
#    parse beholder-stats; # populate the message with stat fields like $uptimeSeconds
#    parse each-field-as-message; # convert fields to separate messages
#    switch $value { case ~^[0-9]+$~ {} } # drop messages with non-numeric values like $date
#
#    # format the message as line protocol of InfluxDB and send
#    set $host host;
#    set $payload 'beholder,host=$host $key=$value';
#    to udp influx:1234;
#}



###
## SETTINGS
#

# `from` buffers are used when Beholder cannot process incoming messages quickly enough.
# These buffers hold incoming messages while Beholder is reloading.
# Every source has its own buffer; if you are listening on two different TCP ports,
# Beholder will create a separate buffer for each of those ports.

#from_internal_log_buffer_messages_count 1000;
#from_tcp_buffer_messages_count 1000;
#from_udp_buffer_messages_count 1000;

# `to` buffers hold messages to be written to a destination. If a destination cannot accept
# new data quickly enough, Beholder will put it into a buffer. When the buffer is full,
# old messages are deleted to make space for new ones.
# Every destination has its own buffer; if you are writing messages into two different files,
# Beholder will create a separate buffer for each of those files.

#to_file_buffer_messages_count 1000;
#to_shell_buffer_messages_count 1000;
#to_tcp_buffer_messages_count 1000;
#to_udp_buffer_messages_count 1000;
